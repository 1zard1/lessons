# Что такое ACID?
ACID — это набор свойств, которые обеспечивают надежность и целостность данных в транзакционных системах баз данных. ACID расшифровывается как:

1. Атомарность (Atomicity): Каждая транзакция либо полностью выполняется, либо не выполняется вовсе. Это гарантирует, что частичные изменения не будут сохранены в случае сбоя.
2. Согласованность (Consistency): Транзакция переводит базу данных из одного согласованного состояния в другое, сохраняя при этом все правила и ограничения.
3. Изоляция (Isolation): Одновременные транзакции не должны мешать друг другу. Промежуточные состояния одной транзакции не видны другим до завершения.
4. Устойчивость (Durability): После завершения транзакции её результаты сохраняются даже в случае сбоя системы.

# Какими основными свойствами должна обладать транзакционная база данных?
ACID

# Какое из свойств ACID является мнимым?
На практике, все четыре свойства ACID важны для различных аспектов работы с базами данных. Тем не менее, в некоторых случаях разработчики могут уделять меньше внимания изоляции (Isolation), особенно в системах, где высокая производительность и масштабируемость важнее строгой изоляции транзакций.

# Какие отличия есть между SQL и NoSQL базами данных?
SQL и NoSQL базы данных имеют несколько ключевых отличий, которые делают их подходящими для разных задач и сценариев использования. Вот основные различия:

Структура данных
  SQL: Используют реляционную модель данных, где данные хранятся в таблицах с четко определенными строками и столбцами. Каждая таблица имеет схему, которая определяет структуру данных.
  NoSQL: Используют нереляционные модели данных, такие как документы, ключ-значение, графы или колонки. Эти базы данных имеют более гибкие схемы, что позволяет хранить структурированные, полуструктурированные и неструктурированные данные12.
Масштабируемость
  SQL: Обычно масштабируются вертикально, то есть путем увеличения мощности одного сервера (добавление CPU, RAM и т.д.).
  NoSQL: Масштабируются горизонтально, что означает добавление новых серверов для распределения нагрузки23.
Схема
  SQL: Имеют жестко заданную схему, которая требует определения структуры данных перед их использованием.
  NoSQL: Имеют динамическую схему, что позволяет изменять структуру данных без необходимости изменения всей базы данных13.
Язык запросов
  SQL: Используют язык структурированных запросов (SQL) для управления и манипуляции данными.
  NoSQL: Могут использовать различные языки запросов в зависимости от типа базы данных (например, MongoDB использует собственный язык запросов для работы с документами)2.
Поддержка транзакций
  SQL: Обеспечивают полную поддержку ACID-транзакций (атомарность, согласованность, изоляция, устойчивость), что гарантирует надежность и целостность данных.
  NoSQL: Некоторые NoSQL базы данных поддерживают ACID-транзакции, но многие из них ориентированы на eventual consistency (конечную согласованность), что может быть более подходящим для распределенных систем12.
Примеры использования
  SQL: Подходят для приложений, где важна целостность данных и сложные запросы, такие как банковские системы, системы управления запасами и CRM.
  NoSQL: Подходят для приложений, требующих высокой производительности и масштабируемости, таких как социальные сети, системы аналитики больших данных и интернет-магазины12.

# Какие существуют базы данных?
SQL СУБД:
- PostrgeSQL
- MySQL
- Microsoft SQL Server
- Oracle Database
- SQLite

NoSQL СУБД:
- MongoDB
- ClickHouse

Гибридные БД:
- Redis
- Tarantool

# Что такое транзакция?
Транзакция — это минимальная логически осмысленная операция, которая имеет смысл и может быть совершена только полностью. В контексте баз данных транзакция представляет собой последовательность операций, которые выполняются как единое целое, обеспечивая свойства ACID (атомарность, согласованность, изоляция и устойчивость). Примеры:
- Финансовые транзакции: Перевод денег между счетами, оплата товаров и услуг.
- Банковские операции: Снятие наличных, зачисление зарплаты, перевод денег на карту.
- Транзакции в базах данных: Вставка, обновление или удаление записей в таблице базы данных.

# Что такое индексы в базе данных? Зачем они нужны? Назовите плюсы и минусы индексации.
Плюсы:
- значительно ускоряют операции выборки и извлечения данных

Минусы:
- замедляют процессы обновления, добавления, вставки данных в базу, так как база требует обновления индексов
- увеличивают размер базы данных, индексы занимают дополнительное место

Индексировать следует лишь те поля, по которым точно будет производиться поиск, чтобы излишне не замедлять базу и не увеличивать её размер.

# Приходилось ли помимо ORM писать напрямую запросы к базе данных? В каких случаях это требовалось?
Django ORM плохо оптимизирует JOIN запросы, в таких случаях приходится писать прямые SQL запросы к базе данных.

# Какие типы JOIN есть в SQL?
- INNER JOIN
- LEFT JOIN
- RIGHT JOIN
- FULL OUTER JOIN
- CROSS JOIN
- SELF JOIN

# Есть две таблицы - на 10 и на 5 записей. Сколько записей станет при CROSS JOIN объединении? А при INNER JOIN?
При CROSS JOIN в объединённой таблице записей будет 50, а при INNER JOIN 10 или 5 записей.

# Что такое уровни изоляции?
Это разграничение прав между параллельными транзакциями на доступ к общим ячейкам базы данных. Выделяют 4 уровня изоляции:
- Read Uncommitted (RU) - транзакция может читать данные, изменяемые другими незафиксированными транзакциями, что может привести к чтению "грязных" данных
- Read Committed (RC) - транзакция может читать только данные, зафиксированные в базе данных на момент чтения или после, если данные были закоммичены
- Repeatable Read (RR) - транзакция не будет видеть изменения, сделанные другими транзакциями после начала чтения, что может привести к фантомным чтениям
- Serializable (SE) - транзакции выполняются последовательно, что гарантирует изоляцию транзакций и отсутствие фантомных чтений

# Как в SQL-запросах использовать CTE, группировки, агрегации?
CTE — это временные результирующие наборы данных, которые можно использовать в основном запросе. Они помогают упростить сложные запросы и улучшить их читаемость.

```sql
  WITH EmployeeCTE AS (
      SELECT id, name, salary, managerId
      FROM Employee
      WHERE salary > 50000
  )
  SELECT * FROM EmployeeCTE;
```
Группировка используется для объединения строк с одинаковыми значениями в указанных столбцах и выполнения агрегатных функций на каждой группе.

```sql
  SELECT department, COUNT(*) AS employee_count
  FROM Employee
  GROUP BY department;
```

Агрегатные функции, такие как COUNT, SUM, AVG, MIN, и MAX, применяются к группам строк для вычисления значений на основе группы.

```sql
  SELECT department, AVG(salary) AS average_salary
  FROM Employee
  GROUP BY department;
```

# В чём заключается проблема в ORM системах, которая называется N + 1?
Проблема N+1 в ORM (Object-Relational Mapping) системах возникает, когда при доступе к связанным объектам происходит большое количество запросов к базе данных, что может привести к неэффективности и плохой производительности.

N+1 означает, что основной запрос выполняется один раз для получения основных данных, а затем для каждого полученного объекта выполняется дополнительный запрос для загрузки связанных данных. Это может происходить, например, когда у вас есть сущность "Заказ" и каждый заказ имеет связь с сущностью "Клиент". Если вы запрашиваете список заказов, а затем для каждого заказа отдельно запрашиваете данные о клиенте, то возникает проблема N+1. Проблема N+1 может приводить к следующим негативным эффектам:
- избыточное количество запросов к базе данных, что может вызывать задержки и негативно влиять на производительность вашего приложения
- загрузка большого объема данных, которые могут не понадобиться
- потеря преимуществ, которые могут предоставлять более эффективные запросы, объединяющие связанные данные

Одним из способов решения проблемы N+1 является использование механизмов предварительной загрузки (eager loading), предоставляемых ORM системами. Предварительная загрузка позволяет сделать единственный запрос, чтобы получить все необходимые данные, включая связанные объекты.




